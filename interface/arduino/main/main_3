main3#include "PluggableUSBHID.h"
#include "USBKeyboard.h"
#include "Ultrasonic.h"

USBKeyboard Keyboard;

const int buttonAPin = 5; // A button
const int buttonBPin = 6; // B button
const int buttonCPin = 7; // C button / OK
const int buttonDPin = 10; // D button

int lastButtonState[4] = { HIGH, HIGH, HIGH, HIGH }; // previous state of buttons
boolean isButtonPressed[4] = { false, false, false, false }; // is each button currently pressed down?
const int letterOffsets[4] = { 0, 1, 2, 3 }; // ASCII code offset for each letter

// define the trigger and echo pins for the ultrasonic sensor
const int triggerPin = 11;
const long distanceThreshold = 10; // distance treshold in cm
int distanceTimer = 0;
bool closeTimerStarted = false;
unsigned long closeTimerStart;

// create an Ultrasonic object with the trigger pin
Ultrasonic ultrasonic(triggerPin);

void setup() {
  // initialize serial communication at 9600 bits per second:
  Serial.begin(9600);
  // make the button pins inputs with pull-up resistors:
  pinMode(buttonAPin, INPUT_PULLUP);
  pinMode(buttonBPin, INPUT_PULLUP);
  pinMode(buttonCPin, INPUT_PULLUP);
  pinMode(buttonDPin, INPUT_PULLUP);

  // set the trigger pin as an output:
  pinMode(triggerPin, OUTPUT);
}

void processButton(int index, int buttonState) {
  // calculate the corresponding key based on the button index:
  char key = 'a' + letterOffsets[index];

  // check if the button is pressed:
  if (buttonState == LOW && lastButtonState[index] == HIGH) {
    // press the corresponding key if it hasn't already been pressed:
    if (!isButtonPressed[index]) {
      Keyboard.printf("%c", key);
      isButtonPressed[index] = true;
      delay(50); // add a 50ms delay to debounce the button
    }
  }
  // check if the button is released:
  else if (buttonState == HIGH && lastButtonState[index] == LOW) {
    // release the corresponding key if it's currently pressed:
    if (isButtonPressed[index]) {
      // release the key by sending a null character
      Keyboard.printf("%c", (uint8_t) 0);
      isButtonPressed[index] = false;
      delay(50); // add a 50ms delay to debounce the button
    }
  }
  // save the current state of the button:
  lastButtonState[index] = buttonState;
}

void loop() {
  // process each button:
  processButton(0, digitalRead(buttonAPin));
  processButton(1, digitalRead(buttonBPin));
  processButton(2, digitalRead(buttonCPin));
  processButton(3, digitalRead(buttonDPin));

  // read the distance from the ultrasonic sensor:
  long distance = ultrasonic.read();
  delay(200); // add a delay to prevent rapid readings

  if (distance >= 0 && distance < distanceThreshold) {
    // trigger the 'D' key:
    Serial.println("distance (close): " + String(distance));
    if (!closeTimerStarted) {
      // start the timer
      Serial.println("Resetting timer...");
      closeTimerStarted = true;
      closeTimerStart = millis();
    } else if (millis() - closeTimerStart >= 3000) {
      Serial.println("Timer over...");
      // distance has been close for at least 3 seconds, trigger the function
      processButton(3, HIGH);
      // reset the timer
      closeTimerStarted = false;
    }
  } else {
    // release the 'D' key:
    processButton(3, LOW);
    Serial.println("distance (far): " + String(distance));
    // reset the timer
    closeTimerStarted = false;
  }
}